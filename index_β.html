<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作品ランダムセレクター</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512' fill='%2306b6d4'><path d='M32 32C14.3 32 0 46.3 0 64V448c0 17.7 14.3 32 32 32H480c17.7 0 32-14.3 32-32V64c0-17.7-14.3-32-32-32H32zM160 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 0a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm-96 96a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm-96 96a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 0a32 32 0 1 1 0 64 32 32 0 1 1 0-64z'/></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        .transition-all {
            transition: all 0.3s ease-in-out;
        }

        #sliding-fab-drawer {
            max-width: 0;
            padding-left: 0;
            padding-right: 0;
            overflow: hidden;
        }

        #sliding-fab-container.drawer-open #sliding-fab-drawer {
            max-width: 100px; /* ドロワーが開いたときの幅 (ボタンサイズに応じて調整) */
            padding-left: 0.75rem; /* p-3 */
            padding-right: 0.75rem; /* p-3 */
        }
        /* ドロワーが開いたときにアイコンを回転 ( < → > ) */
        #sliding-fab-container.drawer-open #sliding-fab-icon {
            transform: rotate(180deg);
        }
        /* モーダル表示時にドロワーを隠す (古い .fab-hidden と同じ役割) */
        #sliding-fab-container.fab-hidden {
             transform: translateX(100%) translateY(-50%);
             opacity: 0;
             pointer-events: none;
        }
        /* 隠すときのアニメーション */
        #sliding-fab-container {
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #image-compare-modal, #image-compare-modal-backdrop {
            transition: opacity 0.3s ease-out;
            opacity: 0;
            pointer-events: none;
        }
        #image-compare-modal.active, #image-compare-modal-backdrop.active {
            opacity: 1;
            pointer-events: auto;
        }
        #image-compare-modal.active > div {
            transform: translateY(0) scale(1);
            opacity: 1;
        }
        #image-compare-modal > div {
            transform: translateY(-20px) scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        .modal-content {
            max-height: 85vh;
        }
        .view-btn-active {
             background-color: #0f766e; /* teal-700 */
             color: white;
        }
        .work-list-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            background-color: #1f2937; /* gray-800 */
            border-radius: 0.75rem;
            transition: background-color 0.2s;
        }
        .work-list-item:hover {
            background-color: #374151; /* gray-700 */
        }
        .date-filter-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
        }
        .btn-disabled {
            background-color: #4b5563;
            cursor: not-allowed;
        }
        .border-red-500 {
            border-color: #ef4444;
        }
        summary {
            list-style: none;
            cursor: pointer;
        }
        summary::-webkit-details-marker {
            display: none;
        }
        details[open] > summary .chevron-icon {
            transform: rotate(180deg);
        }
        .chevron-icon {
            transition: transform 0.2s ease-in-out;
        }
        .tag-item-and { background-color: #059669 !important; color: white !important; }
        .tag-item-or { background-color: #2563eb !important; color: white !important; }
        .tag-item-not { background-color: #be123c !important; color: white !important; text-decoration: line-through; }
        .stats-tab-active {
            background-color: #0f766e;
            color: white;
        }
        .site-badge {
            position: absolute;
            top: 6px;
            left: 6px;
            height: 16px;
            line-height: 16px;
            padding: 0 5px;
            font-size: 10px;
            font-weight: 800;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans antialiased">
    
    <div id="version-display" class="fixed top-2 right-3 text-xs text-gray-600 font-mono z-[60]"></div>

    <div id="debug-banner" class="hidden bg-amber-600 text-black text-center py-1 font-bold text-sm sticky top-0 z-[60]">
          デバッグモード実行中 - データは保存されません
    </div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 z-[100] flex items-center justify-center p-4">
        <div id="loading-content" class="text-center transition-opacity duration-300 opacity-0">
            <i class="fas fa-spinner fa-spin fa-3x text-teal-400"></i>
            <p id="loading-text" class="mt-4 text-gray-400">アプリケーションを初期化中...</p>
            <div class="w-64 mx-auto mt-4 bg-gray-700 rounded-full h-2.5">
                <div id="loading-progress-bar" class="bg-teal-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
    </div>


    <!-- Main Container -->
    <div id="app-container" class="min-h-screen p-4 md:p-8 opacity-0 transition-opacity duration-500">
        <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Left Column: Controls -->
            <aside class="lg:col-span-1 space-y-6">
                <!-- Data Sync Panel (Collapsible) -->
                <details id="sync-panel-details" class="bg-gray-800 rounded-xl shadow-lg">
                    <summary class="p-6 flex justify-between items-center">
                        <h2 class="text-xl font-bold text-teal-400 flex items-center"><i class="fas fa-sync-alt mr-3"></i>データ同期</h2>
                        <i class="fas fa-chevron-down chevron-icon"></i>
                    </summary>
                    <div class="px-6 pb-6">
                        <div class="space-y-3 pt-2 border-t border-gray-700">
                            <div class="flex items-center bg-gray-700 rounded-lg p-2">
                                <input type="text" id="syncIdDisplay" class="bg-transparent w-full text-gray-300 focus:outline-none" readonly>
                                <button id="copySyncIdBtn" class="ml-2 px-3 py-1 bg-teal-600 hover:bg-teal-700 rounded-md text-sm transition-colors"><i class="fas fa-copy"></i></button>
                            </div>
                            <select id="syncIdHistory" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-teal-500"></select>
                            <div class="flex items-center">
                                <input type="text" id="newSyncIdInput" placeholder="新しい同期IDをペースト" class="w-full bg-gray-700 border border-gray-600 rounded-l-lg p-2 focus:outline-none focus:ring-2 focus:ring-teal-500" autocomplete="off">
                                <button id="loadSyncIdBtn" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 rounded-r-lg font-semibold transition-colors flex-shrink-0">読込</button>
                            </div>
                            <div class="flex space-x-2 pt-2">
                                <button id="clearHistoryBtn" class="w-full text-sm px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition-colors">履歴クリア</button>
                                <button id="deleteDataBtn" class="w-full text-sm px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold transition-colors">全作品削除</button>
                            </div>
                             <div class="pt-2">
                                <button id="toggleDebugModeBtn" class="w-full text-sm px-4 py-2 bg-amber-600 hover:bg-amber-700 rounded-lg transition-colors">デバッグモード開始</button>
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Work Registration Panel (Collapsible) -->
                <details id="registration-panel-details" class="bg-gray-800 rounded-xl shadow-lg">
                    <summary class="p-6 flex justify-between items-center">
                        <h2 class="text-xl font-bold text-lime-400 flex items-center"><i class="fas fa-plus-circle mr-3"></i>作品登録</h2>
                        <i class="fas fa-chevron-down chevron-icon"></i>
                    </summary>
                    <div class="px-6 pb-6">
                         <form id="addWorkForm" class="space-y-4 pt-2 border-t border-gray-700">
                            <div>
                                <label for="workNameInput" class="block text-sm font-medium text-gray-400 mb-1">作品名</label>
                                <div class="flex items-center gap-2">
                                    <input type="text" name="workName" id="workNameInput" placeholder="作品名" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-lime-500" required autocomplete="off">
                                    <button type="button" data-action="external-search-reg" class="flex-shrink-0 w-10 h-10 bg-emerald-600 hover:bg-emerald-700 rounded-lg text-white flex items-center justify-center" title="外部サイトで検索"><i class="fas fa-globe-asia"></i></button>
                                </div>
                            </div>
                            <select name="workGenre" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-lime-500" required>
                                <option value="漫画">漫画</option>
                                <option value="ゲーム">ゲーム</option>
                                <option value="動画">動画</option>
                            </select>
                            <div>
                                <label for="workUrlInput" class="block text-sm font-medium text-gray-400 mb-1">作品URL (任意)</label>
                                <input type="url" name="workUrl" id="workUrlInput" placeholder="https://..." class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-lime-500" autocomplete="off">
                            </div>
                            <input type="text" id="workRegisteredAt" name="workRegisteredAt" placeholder="YYYY/MM/DD" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-lime-500" required autocomplete="off">
                            <div>
                                <label for="workImage" class="block text-sm font-medium text-gray-400 mb-2">画像 (任意, 900KB以下)</label>
                                <input type="file" name="workImage" id="workImage" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-lime-600 file:text-white hover:file:bg-lime-700">
                            </div>
                            <img id="imagePreview" src="" class="hidden max-w-full h-auto mx-auto rounded-lg mt-2">
                            <button type="submit" class="w-full px-4 py-3 bg-lime-600 hover:bg-lime-700 rounded-lg font-bold text-lg transition-colors">登録する</button>
                        </form>
                    </div>
                </details>

                <!-- Lottery Panel -->
                <div id="lottery-panel" class="bg-gray-800 p-6 rounded-xl shadow-lg lg:sticky top-8">
                    <h2 class="text-xl font-bold text-sky-400 mb-4 flex items-center"><i class="fas fa-dice mr-3"></i>抽選</h2>
                    <div class="bg-gray-700 p-4 rounded-lg mb-4 min-h-[60px]">
                        <p class="text-sm text-gray-400">現在の設定:</p>
                        <div id="lotterySummary" class="text-sm">設定を開いて条件を選択してください。</div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="startLotteryBtn" class="w-full px-4 py-4 bg-sky-600 hover:bg-sky-700 rounded-lg font-bold text-xl transition-colors">抽選開始！</button>
                        <button id="openLotterySettingsBtn" class="flex-shrink-0 px-4 py-4 bg-gray-600 hover:bg-gray-700 rounded-lg transition-colors"><i class="fas fa-cog text-xl"></i></button>
                    </div>
                </div>

            </aside>

            <!-- Right Column: Content -->
            <main class="lg:col-span-2 space-y-6 pb-24">
                <!-- List Controls -->
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                     <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-5 gap-3">
                        <div class="md:col-span-2 flex items-center bg-gray-700 rounded-lg px-3">
                            <i class="fas fa-search text-gray-500"></i>
                            <input type="search" id="searchInput" placeholder="作品名で検索..." class="w-full bg-transparent p-2 focus:outline-none ml-2">
                        </div>
                        <div class="md:col-span-2 relative">
                            <button id="sortBtn" class="w-full h-full flex items-center justify-between bg-gray-700 p-2 rounded-lg hover:bg-gray-600 transition-colors">
                                <span id="sortStateLabel">並び替え: 登録日 (降順)</span><i class="fas fa-chevron-down text-sm"></i>
                            </button>
                            <div id="sortDropdown" class="hidden absolute z-20 mt-1 w-full bg-gray-700 rounded-lg shadow-xl py-1">
                                <!-- Sort options will be injected by JS -->
                            </div>
                        </div>
                         <button id="filterBtn" class="md:col-span-1 w-full h-full bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors flex items-center justify-center py-2"><i class="fas fa-filter mr-2"></i>絞り込み</button>
                    </div>
                </div>

                <!-- Active Filters & Count -->
                 <div class="flex flex-wrap gap-4 justify-between items-center px-2">
                    <div id="activeFilters" class="flex flex-wrap gap-2 items-center">
                         <span class="text-sm text-gray-400">絞り込み:</span>
                         <!-- Active filter badges will be injected here -->
                    </div>
                    <span id="workCount" class="flex-shrink-0 px-3 py-1 bg-gray-700 rounded-full text-sm font-semibold">0 作品</span>
                </div>
                
                <!-- Work List Panel -->
                <div>
                    <div class="flex justify-between items-center mb-4 px-2">
                        <h2 class="text-2xl font-bold">登録作品リスト</h2>
                        <div class="flex space-x-1 bg-gray-700 p-1 rounded-lg">
                            <button id="view-grid-btn" aria-label="グリッド表示" class="view-btn p-2 leading-none"><i class="fas fa-th-large"></i></button>
                            <button id="view-list-btn" aria-label="リスト表示" class="view-btn p-2 leading-none"><i class="fas fa-bars"></i></button>
                        </div>
                    </div>
                    <div id="workList" class="transition-all">
                        <!-- Work cards will be injected here -->
                    </div>
                     <div id="workListMessage" class="text-center py-10">
                        <!-- Messages like loading, no data, etc. will be shown here -->
                     </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- FAB Backdrop -->
    <div id="fab-backdrop" class="hidden fixed inset-0 z-20"></div>

    <div id="sliding-fab-container" class="fixed top-1/2 -translate-y-1/2 right-0 z-30 flex items-center">
        
        <div id="sliding-fab-drawer" class="bg-gray-800 rounded-l-lg shadow-lg flex flex-col space-y-3 p-3 transition-all duration-300">
            <button id="manageTagsFab" title="タグ管理" aria-label="タグ管理" class="w-14 h-14 bg-purple-600 hover:bg-purple-700 rounded-full text-white flex items-center justify-center shadow-lg"><i class="fas fa-tags text-xl"></i></button>
            <button id="statsFab" title="統計" aria-label="統計" class="w-14 h-14 bg-amber-600 hover:bg-amber-700 rounded-full text-white flex items-center justify-center shadow-lg"><i class="fas fa-chart-pie text-xl"></i></button>
            <button id="externalSearchFab" title="外部サイト検索" aria-label="外部サイト検索" class="w-14 h-14 bg-emerald-600 hover:bg-emerald-700 rounded-full text-white flex items-center justify-center shadow-lg"><i class="fas fa-globe-asia text-xl"></i></button>
            <button id="historyFab" title="総合履歴" aria-label="総合履歴" class="w-14 h-14 bg-gray-600 hover:bg-gray-700 rounded-full text-white flex items-center justify-center shadow-lg"><i class="fas fa-history text-xl"></i></button>
            <a href="price_comparison.html" title="価格比較ツール" aria-label="価格比較ツール">
                 <button class="w-14 h-14 bg-cyan-600 hover:bg-cyan-700 rounded-full text-white flex items-center justify-center shadow-lg"><i class="fas fa-balance-scale-right text-xl"></i></button>
            </a>
            <button id="drawerLotteryFab" title="抽選パネルへ" aria-label="抽選パネルへ移動" class="lg:hidden w-14 h-14 bg-sky-600 hover:bg-sky-700 rounded-full text-white flex items-center justify-center shadow-lg">
                <i class="fas fa-dice text-xl"></i>
            </button>
        </div>
        
        <button id="sliding-fab-toggle" aria-label="メニューを開く" class="w-10 h-24 bg-indigo-600 hover:bg-indigo-700 text-white flex items-center justify-center rounded-l-lg shadow-lg -mr-1">
            <i id="sliding-fab-icon" class="fas fa-chevron-left transition-transform duration-300"></i>
        </button>
    </div>

    <!-- Modals -->
    <div id="modal-backdrop" class="hidden fixed inset-0 bg-black bg-opacity-70 z-40 transition-opacity"></div>

    <!-- Generic Modal Wrapper -->
    <div id="modal-wrapper" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div id="modal-container" class="bg-gray-800 rounded-2xl shadow-2xl w-full max-w-2xl transform transition-transform scale-95 opacity-0">
             <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h3 id="modal-title" class="text-xl font-bold">Modal Title</h3>
                <button id="modal-close-btn" aria-label="閉じる" class="text-gray-400 hover:text-white"><i class="fas fa-times fa-lg"></i></button>
            </div>
            <div id="modal-content-host" class="p-6 overflow-y-auto modal-content">
                <!-- Modal content will be injected here -->
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-5 right-5 bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-all duration-300 z-[70]">
        <p id="toast-message">Message</p>
    </div>

    <!-- Simple Password Overlay -->
    <div id="password-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-95 z-[90] flex items-center justify-center p-4">
        <div class="w-full max-w-sm">
            <form id="password-form" class="bg-gray-800 p-8 rounded-2xl shadow-2xl space-y-6">
                <h2 class="text-2xl font-bold text-center text-gray-300">認証</h2>
                <div id="password-error" class="hidden text-sm text-center bg-red-900 border border-red-700 text-red-300 p-2 rounded-lg"></div>
                <div>
                    <label for="password-input" class="block text-sm font-medium text-gray-400 mb-1">パスワード</label>
                    <input type="password" id="password-input" required class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-sky-500" autocomplete="current-password">
                </div>
                <button type="submit" class="w-full px-4 py-3 bg-sky-600 hover:bg-sky-700 rounded-lg font-bold text-lg transition-colors">入室</button>
            </form>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-[80] flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-xl shadow-lg p-6 max-w-sm w-full">
            <h3 id="confirm-title" class="text-lg font-bold mb-4">確認</h3>
            <p id="confirm-message" class="text-gray-300 mb-6">この操作を続けてもよろしいですか？</p>
            <div class="flex justify-end space-x-4">
                <button id="confirm-cancel" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition-colors">キャンセル</button>
                <button id="confirm-ok" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold transition-colors">OK</button>
            </div>
        </div>
    </div>

    <div id="image-compare-modal-backdrop" class="fixed inset-0 bg-black bg-opacity-75 z-[90]"></div>
    <div id="image-compare-modal" class="fixed inset-0 flex items-center justify-center z-[91] p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg">
            <div class="px-4 py-3 sm:px-6 flex justify-between items-center border-b border-gray-700">
                <h3 class="text-lg font-medium text-white">画像変更の確認</h3>
                <button type="button" id="image-compare-close-btn" class="text-gray-400 hover:text-white" aria-label="閉じる">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>
            <div class="p-4 sm:p-6 text-center">
                <p class="text-sm text-gray-300 mb-4">変更後の画像を確認してください。</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <p class="text-gray-400 text-xs mb-2">現在の画像</p>
                        <img id="compare-original-image" src="" alt="現在の画像" class="w-full h-32 object-contain rounded-md border border-gray-700">
                    </div>
                    <div>
                        <p class="text-gray-400 text-xs mb-2">新しい画像</p>
                        <img id="compare-new-image" src="" alt="新しい画像" class="w-full h-32 object-contain rounded-md border border-gray-700">
                    </div>
                </div>
            </div>
            <div class="px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse sm:justify-center">
                <button type="button" id="image-compare-confirm-btn" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-indigo-600 text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:ml-3 sm:w-auto sm:text-sm">
                    決定して変更
                </button>
                <button type="button" id="image-compare-cancel-btn" class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-700 shadow-sm px-4 py-2 bg-gray-600 text-base font-medium text-gray-100 hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">
                    キャンセル
                </button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            updateDoc, 
            deleteDoc, 
            onSnapshot, 
            collection, 
            query, 
            writeBatch,
            Timestamp,
            serverTimestamp,
            getDocs,
            arrayUnion,
            arrayRemove,
            deleteField
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- 1. UI Helper Functions ---
        // (Grok/ChatGPT案: 構造化)
        // これら2つは利便性のためにグローバルに残します
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);


        // --- 2. App State ---
        // (Grok/ChatGPT案: 状態管理の集約)
        // すべてのグローバル変数をこのオブジェクトにまとめます
        const AppState = {
            firebaseApp: null,
            auth: null,
            db: null,
            
            // App Config
            DEFAULT_APP_ID: 'r18-random-selector',
            appId: typeof __app_id !== 'undefined' ? __app_id : 'r18-random-selector',
            appVersion: 'v2.20.1-refactor', // バージョンを更新
            MASTER_PASSWORD: '07143674',
            firebaseConfigStr: typeof __firebase_config !== 'undefined' ? __firebase_config : `{
                "apiKey": "AIzaSyAnlTrmb0MW8yznBxpWF6B83R9luFnGVts",
                "authDomain": "serecter222.firebaseapp.com",
                "projectId": "serecter222",
                "storageBucket": "serecter222.appspot.com",
                "messagingSenderId": "1019715441654",
                "appId": "1:1019715441654:web:6caa7779148cce46c92dd7"
            }`,

            // State Management
            works: [],
            tags: [],
            unsubscribeWorks: () => {},
            unsubscribeTags: () => {},
            syncId: '',
            currentUser: null,
            loadingTimeout: null,
            stallTimeout: null,
            isLoadComplete: false,
            loadingStatus: { auth: false, works: false, tags: false },
            listViewMode: localStorage.getItem('listViewMode') || 'grid',
            showSiteIcon: localStorage.getItem('showSiteIcon') === 'false' ? false : true,
            modalStateStack: [],
            activeCharts: {},
            isDebugMode: false,
            checkModalDirtyState: () => false,

            // Image Edit State
            tempNewImageUrl: null,
            deleteImageFlag: false,

            // Filters and Sort State
            defaultDateFilter: () => ({ mode: 'none', date: '', startDate: '', endDate: '' }),
            listFilters: {
                genres: new Set(),
                rating: { type: 'exact', value: 0 },
                andTagIds: new Set(),
                orTagIds: new Set(),
                notTagIds: new Set(),
                dateFilter: { mode: 'none', date: '', startDate: '', endDate: '' },
                unratedOrUntaggedOnly: false,
            },
            sortState: {
                by: 'registeredAt',
                order: 'desc',
            },
            searchQuery: '',
            searchDebounceTimer: null,
            expandedTagsWorkIds: new Set(), // (Grok/ChatGPT案: クリーンアップ) ※これは削除候補でしたが、`renderWorkCard`でまだ使われているため残します

            // Lottery State
            lotterySettings: {
                mood: 'default',
                genres: new Set(),
                andTagIds: new Set(),
                orTagIds: new Set(),
                notTagIds: new Set(),
                dateFilter: { mode: 'none', date: '', startDate: '', endDate: '' },
                priority: 'new',
                method: 'normal',
                unratedOrUntaggedOnly: false,
            },

            // UI Elements (ここで一元管理)
            ui: {}
        };
        // listFilters.dateFilter の初期化
        AppState.listFilters.dateFilter = AppState.defaultDateFilter();
        // lotterySettings.dateFilter の初期化
        AppState.lotterySettings.dateFilter = AppState.defaultDateFilter();


        // --- 3. App Logic ---
        // (Grok/ChatGPT案: 関数のグループ化)
        // すべての関数を App オブジェクトにまとめます
        const App = {

            // --- Initialization ---
            init: () => {
                $('#version-display').textContent = AppState.appVersion;

                // UI要素の参照をキャッシュ
                AppState.ui = {
                    loadingOverlay: $('#loading-overlay'),
                    loadingContent: $('#loading-content'),
                    loadingText: $('#loading-text'),
                    loadingProgressBar: $('#loading-progress-bar'),
                    appContainer: $('#app-container'),
                    workListEl: $('#workList'),
                    workListMessage: $('#workListMessage'),
                    workCountEl: $('#workCount'),
                    syncIdDisplay: $('#syncIdDisplay'),
                    copySyncIdBtn: $('#copySyncIdBtn'),
                    newSyncIdInput: $('#newSyncIdInput'),
                    loadSyncIdBtn: $('#loadSyncIdBtn'),
                    syncIdHistoryEl: $('#syncIdHistory'),
                    clearHistoryBtn: $('#clearHistoryBtn'),
                    deleteDataBtn: $('#deleteDataBtn'),
                    addWorkForm: $('#addWorkForm'),
                    searchInput: $('#searchInput'),
                    sortBtn: $('#sortBtn'),
                    sortDropdown: $('#sortDropdown'),
                    sortStateLabel: $('#sortStateLabel'),
                    filterBtn: $('#filterBtn'),
                    activeFiltersEl: $('#activeFilters'),
                    viewGridBtn: $('#view-grid-btn'),
                    viewListBtn: $('#view-list-btn'),
                    lotterySummaryEl: $('#lotterySummary'),
                    startLotteryBtn: $('#startLotteryBtn'),
                    openLotterySettingsBtn: $('#openLotterySettingsBtn'),
                    slidingFabContainer: $('#sliding-fab-container'),
                    slidingFabToggle: $('#sliding-fab-toggle'),
                    fabBackdrop: $('#fab-backdrop'),
                    historyFab: $('#historyFab'),
                    externalSearchFab: $('#externalSearchFab'),
                    statsFab: $('#statsFab'),
                    manageTagsFab: $('#manageTagsFab'),
                    drawerLotteryFab: $('#drawerLotteryFab'),
                    modalBackdrop: $('#modal-backdrop'),
                    modalWrapper: $('#modal-wrapper'),
                    modalContainer: $('#modal-container'),
                    modalTitle: $('#modal-title'),
                    modalContentHost: $('#modal-content-host'),
                    modalCloseBtn: $('#modal-close-btn'),
                    imageCompareModalBackdrop: $('#image-compare-modal-backdrop'),
                    imageCompareModal: $('#image-compare-modal'),
                    imageCompareCloseBtn: $('#image-compare-close-btn'),
                    compareOriginalImage: $('#compare-original-image'),
                    compareNewImage: $('#compare-new-image'),
                    imageCompareConfirmBtn: $('#image-compare-confirm-btn'),
                    imageCompareCancelBtn: $('#image-compare-cancel-btn'),
                    passwordOverlay: $('#password-overlay'),
                    passwordForm: $('#password-form'),
                    passwordInput: $('#password-input'),
                    passwordError: $('#password-error'),
                    toastEl: $('#toast'),
                    toastMessageEl: $('#toast-message'),
                    confirmModal: $('#confirm-modal'),
                    confirmTitle: $('#confirm-title'),
                    confirmMessage: $('#confirm-message'),
                    confirmOkBtn: $('#confirm-ok'),
                    confirmCancelBtn: $('#confirm-cancel'),
                };

                // パスワード認証のイベントリスナーを設定
                AppState.ui.passwordForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    if (AppState.ui.passwordInput.value === AppState.MASTER_PASSWORD) {
                        localStorage.setItem('passwordAuthTimestamp', Date.now().toString());
                        AppState.ui.passwordOverlay.classList.add('hidden');
                        AppState.ui.passwordError.classList.add('hidden');
                        App.startApp();
                    } else {
                        AppState.ui.passwordError.textContent = 'パスワードが違います。';
                        AppState.ui.passwordError.classList.remove('hidden');
                    }
                });

                App.checkSimpleAuth();
            },

            checkSimpleAuth: () => {
                const authTimestamp = localStorage.getItem('passwordAuthTimestamp');
                if (authTimestamp) {
                    const thirtyDays = 30 * 24 * 60 * 60 * 1000;
                    if (Date.now() - parseInt(authTimestamp, 10) < thirtyDays) {
                        AppState.ui.passwordOverlay.classList.add('hidden');
                        App.startApp();
                        return;
                    } else {
                        localStorage.removeItem('passwordAuthTimestamp');
                    }
                }
                AppState.ui.passwordOverlay.classList.remove('hidden');
                AppState.ui.loadingOverlay.classList.add('hidden');
            },
            
            startApp: () => {
                AppState.ui.loadingOverlay.classList.remove('hidden');
                App.initializeFirebase();
                App.initializeDateInputs(document.body);

                if (window.innerWidth < 1024) {
                    $('#sync-panel-details').removeAttribute('open');
                    $('#registration-panel-details').removeAttribute('open');
                }
                App.setupEventListeners();
            },

            // --- Utility Functions ---
            escapeHTML: (str) => str.replace(/"/g, '&quot;').replace(/'/g, '&#39;'),
            
            isValidDate: (dateString) => {
                if (!/^\d{4}\/\d{2}\/\d{2}$/.test(dateString)) return false;
                const d = new Date(dateString.replace(/\//g, '-'));
                if (isNaN(d.getTime())) return false;
                return d.toISOString().slice(0, 10).replace(/-/g, '/') === dateString;
            },

            showToast: (message, type = 'info', duration = 3000) => {
                let finalDuration = duration;
                if (type === 'error') {
                    finalDuration = 5000; // エラー時は5秒
                    AppState.ui.toastEl.classList.add('bg-red-600'); // 色も赤くする
                    AppState.ui.toastEl.classList.remove('bg-gray-700');
                } else {
                    AppState.ui.toastEl.classList.add('bg-gray-700');
                    AppState.ui.toastEl.classList.remove('bg-red-600');
                }
                AppState.ui.toastMessageEl.textContent = message;
                AppState.ui.toastEl.classList.remove('translate-y-20', 'opacity-0');
                AppState.ui.toastEl.classList.add('translate-y-0', 'opacity-100');
                setTimeout(() => {
                    AppState.ui.toastEl.classList.remove('translate-y-0', 'opacity-100');
                    AppState.ui.toastEl.classList.add('translate-y-20', 'opacity-0');
                }, finalDuration); // 変更
            },

            showConfirm: (title, message) => {
                return new Promise((resolve) => {
                    AppState.ui.confirmTitle.textContent = title;
                    AppState.ui.confirmMessage.innerHTML = message;
                    AppState.ui.confirmModal.classList.remove('hidden');

                    const okHandler = () => {
                        AppState.ui.confirmModal.classList.add('hidden');
                        AppState.ui.confirmOkBtn.removeEventListener('click', okHandler);
                        AppState.ui.confirmCancelBtn.removeEventListener('click', cancelHandler);
                        resolve(true);
                    };
                    const cancelHandler = () => {
                        AppState.ui.confirmModal.classList.add('hidden');
                        AppState.ui.confirmOkBtn.removeEventListener('click', okHandler);
                        AppState.ui.confirmCancelBtn.removeEventListener('click', cancelHandler);
                        resolve(false);
                    };
                    
                    AppState.ui.confirmOkBtn.addEventListener('click', okHandler);
                    AppState.ui.confirmCancelBtn.addEventListener('click', cancelHandler);
                });
            },

            formatDate: (timestamp, includeTime = true) => {
                if (!timestamp || !timestamp.toDate) return 'N/A';
                const date = timestamp.toDate();
                const options = {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit',
                    hour12: false
                };
                if (!includeTime) {
                    delete options.hour;
                    delete options.minute;
                }
                return new Intl.DateTimeFormat('ja-JP', options).format(date);
            },

            formatDateForInput: (date) => {
                const d = date instanceof Date ? date : new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}/${month}/${day}`;
            },
            
            debounce: (func, delay) => {
                let timer;
                return (...args) => {
                    clearTimeout(timer);
                    timer = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            },

            getTagObjects: (tagIds) => {
                return Array.from(tagIds || []).map(id => AppState.tags.get(id)).filter(Boolean);
            },

            // --- FAB Menu Logic ---
            toggleFabMenu: () => {
                const isOpen = AppState.ui.slidingFabContainer.classList.toggle('drawer-open');
                AppState.ui.fabBackdrop.classList.toggle('hidden', !isOpen);
                AppState.ui.slidingFabToggle.setAttribute('aria-label', isOpen ? 'メニューを閉じる' : 'メニューを開く');
            },
            
            closeFabMenu: () => {
                AppState.ui.slidingFabContainer.classList.remove('drawer-open');
                AppState.ui.fabBackdrop.classList.add('hidden');
                AppState.ui.slidingFabToggle.setAttribute('aria-label', 'メニューを開く');
            },

            // --- Modal Management ---
            openModal: (title, contentHtml, onOpen = null, options = {}) => {
                App.closeFabMenu();
                AppState.checkModalDirtyState = () => false;
                const { size = 'max-w-2xl' } = options;
                
                Object.values(AppState.activeCharts).forEach(chart => chart.destroy());
                AppState.activeCharts = {};

                AppState.ui.modalContainer.classList.remove('max-w-2xl', 'max-w-4xl', 'max-w-5xl');
                AppState.ui.modalContainer.classList.add(size);
                
                AppState.ui.modalTitle.textContent = title;
                AppState.ui.modalContentHost.innerHTML = contentHtml;
                App.initializeDateInputs(AppState.ui.modalContentHost); 
                AppState.ui.modalBackdrop.classList.remove('hidden');
                AppState.ui.modalWrapper.classList.remove('hidden');
                AppState.ui.slidingFabContainer.classList.add('fab-hidden');
                
                setTimeout(() => {
                    AppState.ui.modalBackdrop.classList.add('opacity-100');
                    AppState.ui.modalContainer.classList.remove('scale-95', 'opacity-0');
                    if (onOpen) onOpen();
                    
                    const firstFocusable = AppState.ui.modalContentHost.querySelector('input, select, button');
                    if (firstFocusable) {
                        setTimeout(() => firstFocusable.focus(), 100);
                    }
                }, 10);
            },

            closeModal: async () => {
                if (AppState.checkModalDirtyState()) {
                    const confirmed = await App.showConfirm("未保存の変更", "変更が保存されていません。本当に閉じますか？");
                    if (!confirmed) return;
                }
                AppState.checkModalDirtyState = () => false;

                if (AppState.modalStateStack.length > 0) {
                    const restorePrevious = AppState.modalStateStack.pop();
                    restorePrevious();
                    return;
                }

                AppState.ui.modalContainer.classList.add('scale-95', 'opacity-0');
                AppState.ui.modalBackdrop.classList.remove('opacity-100');
                AppState.ui.slidingFabContainer.classList.remove('fab-hidden');
                
                setTimeout(() => {
                    AppState.ui.modalBackdrop.classList.add('hidden');
                    AppState.ui.modalWrapper.classList.add('hidden');
                    AppState.ui.modalContentHost.innerHTML = '';
                    Object.values(AppState.activeCharts).forEach(chart => chart.destroy());
                    AppState.activeCharts = {};
                }, 300);
            },

            openImageCompareModal: (originalUrl, newUrl) => {
                AppState.ui.compareOriginalImage.src = originalUrl || 'https://placehold.co/300x200/1f2937/4b5563?text=No+Image';
                AppState.ui.compareNewImage.src = newUrl;
                AppState.ui.imageCompareModalBackdrop.classList.add('active');
                AppState.ui.imageCompareModal.classList.add('active');
            },

            closeImageCompareModal: (clearInput = true) => {
                AppState.ui.imageCompareModalBackdrop.classList.remove('active');
                AppState.ui.imageCompareModal.classList.remove('active');
                
                if (clearInput) {
                    AppState.tempNewImageUrl = null;
                    const editImageUpload = $('#edit-image-upload'); // モーダル内の要素なので$で都度取得
                    if (editImageUpload) editImageUpload.value = '';
                }
            },

            // --- Loading Timeout Logic ---
            updateLoadingProgress: () => {
                if (AppState.isLoadComplete) return;
                let progress = 10;
                if (AppState.loadingStatus.auth) progress += 20;
                if (AppState.loadingStatus.tags) progress += 35;
                if (AppState.loadingStatus.works) progress += 35;
                AppState.ui.loadingProgressBar.style.width = `${progress}%`;
                AppState.ui.loadingText.textContent = `読み込み中... (${progress}%)`;
            },

            handleLoadingTimeout: (isStall = false) => {
                if (AppState.isLoadComplete) return;

                const errorCode = isStall ? 'DATA_STALL' : 'TIMEOUT_30S';
                const errorMessageTitle = isStall ? 'データ取得の停滞' : '読み込みタイムアウト';
                console.error(`Loading failed: ${errorCode}`);

                clearTimeout(AppState.loadingTimeout);
                clearTimeout(AppState.stallTimeout);
                
                const statusParts = [];
                if (!AppState.loadingStatus.auth) statusParts.push('認証');
                if (!AppState.loadingStatus.tags) statusParts.push('タグ');
                if (!AppState.loadingStatus.works) statusParts.push('作品');

                AppState.ui.loadingContent.innerHTML = `... (エラーHTML) ...`; // (省略)
            },
            
            startLoadingTimeout: () => {
                clearTimeout(AppState.loadingTimeout);
                AppState.loadingTimeout = setTimeout(() => App.handleLoadingTimeout(false), 30000);
            },

            handleDataFetchError: (error, type) => {
                 if (AppState.isLoadComplete) return;
                 console.error(`Error fetching ${type}: `, error);
                 clearTimeout(AppState.loadingTimeout);
                 AppState.ui.loadingContent.innerHTML = `... (エラーHTML) ...`; // (省略)
            },

            checkLoadingComplete: () => {
                if (AppState.isLoadComplete) return;
                App.updateLoadingProgress();
                
                if (AppState.loadingStatus.auth && AppState.loadingStatus.works && AppState.loadingStatus.tags) {
                    AppState.isLoadComplete = true;
                    clearTimeout(AppState.loadingTimeout);
                    clearTimeout(AppState.stallTimeout);
                    console.log("All data loaded successfully.");
                    
                    AppState.ui.loadingText.textContent = '読み込み完了！';
                    AppState.ui.loadingProgressBar.style.width = `100%`;

                    setTimeout(() => {
                        AppState.ui.loadingOverlay.classList.add('opacity-0');
                        AppState.ui.appContainer.classList.remove('opacity-0');
                        setTimeout(() => AppState.ui.loadingOverlay.classList.add('hidden'), 500);

                        const lastSelectedId = localStorage.getItem('lastSelectedWorkId');
                        if (lastSelectedId) {
                            localStorage.removeItem('lastSelectedWorkId');
                            const work = AppState.works.find(w => w.id === lastSelectedId);
                            if (work && ((work.rating || 0) === 0 || !work.tagIds || work.tagIds.length === 0)) {
                                setTimeout(() => App.openFeedbackModal(work), 1000); 
                            }
                        }
                    }, 500);
                }
            },

            // --- Firebase & Data Sync Logic ---
            initializeFirebase: () => {
                App.startLoadingTimeout();
                setTimeout(() => { AppState.ui.loadingContent.classList.remove('opacity-0'); }, 100);
                App.updateLoadingProgress();
                try {
                    const firebaseConfig = JSON.parse(AppState.firebaseConfigStr);
                    AppState.firebaseApp = initializeApp(firebaseConfig);
                    AppState.auth = getAuth(AppState.firebaseApp);
                    AppState.db = getFirestore(AppState.firebaseApp);
                    App.setupAuthObserver();
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    AppState.ui.loadingContent.innerHTML = `<p class="text-red-400">Firebaseの初期化に失敗しました。</p>`;
                }
            },

            setupAuthObserver: () => {
                onAuthStateChanged(AppState.auth, user => {
                    if (user) {
                        if (!AppState.loadingStatus.auth) {
                            AppState.currentUser = user;
                            AppState.loadingStatus.auth = true;
                            
                            clearTimeout(AppState.stallTimeout);
                            AppState.stallTimeout = setTimeout(() => App.handleLoadingTimeout(true), 15000);

                            App.checkLoadingComplete();
                            App.setupSyncId();
                        }
                    } else {
                        signInAnonymously(AppState.auth).catch(error => App.handleDataFetchError(error, '匿名認証'));
                    }
                });
            },

            setupSyncId: () => {
                let currentSyncId = localStorage.getItem('r18_sync_id');
                if (!currentSyncId) {
                    currentSyncId = App.generateRandomId();
                    localStorage.setItem('r18_sync_id', currentSyncId);
                }
                App.loadDataSet(currentSyncId);
                App.updateSyncIdHistory(currentSyncId);
            },
            
            loadDataSet: (newSyncId) => {
                if (AppState.syncId === newSyncId && AppState.isLoadComplete) return;
                
                AppState.syncId = newSyncId;
                AppState.ui.syncIdDisplay.value = AppState.syncId;
                localStorage.setItem('r18_sync_id', AppState.syncId);
                
                AppState.unsubscribeWorks();
                AppState.unsubscribeTags();

                AppState.works = [];
                AppState.tags = [];
                App.renderAll();

                if (AppState.currentUser && AppState.syncId && !AppState.isDebugMode) {
                    App.subscribeToWorks();
                    App.subscribeToTags();
                }
            },
            
            updateSyncIdHistory: (newId) => {
                let history = JSON.parse(localStorage.getItem('r18_sync_id_history') || '[]');
                if (newId && !history.includes(newId)) {
                    history.unshift(newId);
                    history = history.slice(0, 10);
                    localStorage.setItem('r18_sync_id_history', JSON.stringify(history));
                }
                App.renderSyncIdHistory();
            },

            renderSyncIdHistory: () => {
                const history = JSON.parse(localStorage.getItem('r18_sync_id_history') || '[]');
                AppState.ui.syncIdHistoryEl.innerHTML = '<option value="">履歴から選択...</option>' + 
                    history.map(id => `<option value="${id}">${id}</option>`).join('');
            },
            
            generateRandomId: (length = 16) => {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
                return result;
            },
            
            subscribeToWorks: () => {
                if (AppState.isDebugMode) return;
                let isFirstLoad = true;
                const worksRef = collection(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/items`);
                AppState.unsubscribeWorks = onSnapshot(worksRef, (snapshot) => {
                    const workChanges = snapshot.docChanges();
                    
                    workChanges.forEach(change => {
                        const data = { id: change.doc.id, ...change.doc.data() };
                        const index = AppState.works.findIndex(w => w.id === change.doc.id);

                        if (change.type === "added") {
                            if (index === -1) AppState.works.push(data);
                        }
                        if (change.type === "modified") {
                            if (index > -1) AppState.works[index] = data;
                        }
                        if (change.type === "removed") {
                            if (index > -1) AppState.works.splice(index, 1);
                        }
                    });

                    if (isFirstLoad) {
                        isFirstLoad = false;
                        AppState.loadingStatus.works = true;
                        App.checkLoadingComplete();
                    }
                    App.renderWorkList();
                }, error => App.handleDataFetchError(error, '作品'));
            },

            subscribeToTags: () => {
                if (AppState.isDebugMode) return;
                let isFirstLoad = true;
                const tagsRef = collection(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/tags`);
                AppState.unsubscribeTags = onSnapshot(tagsRef, (snapshot) => {
                    AppState.tags = new Map(snapshot.docs.map(doc => [doc.id, { id: doc.id, ...doc.data() }]));
                     if (isFirstLoad) {
                        isFirstLoad = false;
                        AppState.loadingStatus.tags = true;
                        App.checkLoadingComplete();
                     }
                     if (!AppState.ui.modalWrapper.classList.contains('hidden') && $('#tag-list')) {
                         $('#tag-list').dispatchEvent(new Event('refresh-tags', {bubbles:true}));
                     }
                     App.renderAll();
                }, error => App.handleDataFetchError(error, 'タグ'));
            },

            // --- Image Processing ---
            processImage: (file) => {
                return new Promise((resolve, reject) => {
                    if (file.size > 900 * 1024) return reject(new Error("ファイルサイズが900KBを超えています。別の画像をお試しください。"));
                    const reader = new FileReader();
                    reader.onload = e => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const MAX_SIZE = 512;
                            let { width, height } = img;
                            if (width > height) {
                                if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; }
                            } else {
                                if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; }
                            }
                            canvas.width = width;
                            canvas.height = height;
                            canvas.getContext('2d').drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', 0.8));
                        };
                        img.src = e.target.result;
                    };
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(file);
                });
            },
            
            // --- CRUD Operations ---
            handleAddWork: async (e) => {
                e.preventDefault();
                if (AppState.isDebugMode) { return App.showToast("デバッグモード中は作品を登録できません。"); }
                const form = e.target;
                const name = form.elements.workName.value.trim();
                const registeredAtStr = App.getDateInputValue('workRegisteredAt'); // 変更
                if (!name || !registeredAtStr) return App.showToast("作品名と登録日は必須です。");
                if (!App.isValidDate(registeredAtStr)) return App.showToast("登録日の形式が正しくありません (YYYY/MM/DD)。");
                if (AppState.works.some(w => w.name.toLowerCase() === name.toLowerCase())) {
                    if (!await App.showConfirm("重複警告", `"${name}" は既に存在します。登録を続けますか？`)) return;
                }
                let imageUrl = null;
                if (form.elements.workImage.files[0]) {
                    try {
                        imageUrl = await App.processImage(form.elements.workImage.files[0]);
                    } catch (error) { return App.showToast(error.message); }
                }
                const url = form.elements.workUrl.value.trim();
                const newWork = {
                    name,
                    genre: form.elements.workGenre.value,
                    sourceUrl: url,
                    registeredAt: Timestamp.fromDate(new Date(registeredAtStr.replace(/\//g, '-'))),
                    imageUrl, selectionCount: 0, rating: 0, tagIds: [], lastSelectedAt: null,
                    selectionHistory: []
                };
                try {
                    const worksRef = collection(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/items`);
                    await setDoc(doc(worksRef), newWork);
                    App.showToast(`"${name}" を登録しました。`);
                    form.reset();
                    $('#imagePreview').classList.add('hidden');
                    $('#workRegisteredAt').value = App.formatDateForInput(new Date());
                } catch (error) {
                    console.error("Error adding work: ", error);
                    App.showToast("作品の登録に失敗しました。時間をおいて再度お試しください。", "error");
                }
            },

            updateWork: async (workId, updatedData) => {
                if (AppState.isDebugMode) {
                    const workIndex = AppState.works.findIndex(w => w.id === workId);
                    if (workIndex !== -1) {
                        AppState.works[workIndex] = { ...AppState.works[workIndex], ...updatedData };
                        App.renderAll();
                    }
                    return true;
                }
                try {
                    const workRef = doc(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/items`, workId);
                    await updateDoc(workRef, updatedData);
                    return true;
                } catch (error) {
                    console.error("Error updating work:", error);
                    App.showToast("作品の更新に失敗しました。", "error");
                    return false;
                }
            },

            deleteWork: async (workId, workName) => {
                if (AppState.isDebugMode) { return App.showToast("デバッグモード中は作品を削除できません。"); }
                if (!await App.showConfirm("作品の削除", `「${workName}」を本当に削除しますか？<br>この操作は取り消せません。`)) return;
                try {
                    await deleteDoc(doc(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/items`, workId));
                    App.showToast(`「${workName}」を削除しました。`);
                } catch (error) {
                    console.error("Error deleting work: ", error);
                    App.showToast("作品の削除に失敗しました。", "error");
                }
            },

            addTag: async (name, color) => {
                 if (AppState.isDebugMode) { return App.showToast("デバッグモード中はタグを作成できません。"); }
                 const normalizedName = name.trim().toLowerCase();
                 if ([...AppState.tags.values()].some(t => t.name.toLowerCase() === normalizedName)) {
                    App.showToast("同じ名前のタグが既に存在します。", "error"); return null;
                 }
                 const newTag = {
                    name: name.trim(), color, useCount: 0,
                    createdAt: Timestamp.now(), lastSelectedAt: null
                 };
                 try {
                    const docRef = doc(collection(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/tags`));
                    await setDoc(docRef, newTag);
                    App.showToast(`タグ「${name}」を作成しました。`);
                    return { id: docRef.id, ...newTag };
                 } catch (error) {
                    console.error("Error adding tag:", error);
                    App.showToast("タグの作成に失敗しました。", "error"); return null;
                 }
            },
            
            deleteTag: async (tagId) => {
                 if (AppState.isDebugMode) { return App.showToast("デバッグモード中はタグを削除できません。"); }
                 const tagToDelete = AppState.tags.get(tagId);
                 if (!tagToDelete || !await App.showConfirm("タグの削除", `タグ「${tagToDelete.name}」を削除しますか？<br>全ての作品からこのタグが解除されます。`)) return;
                 try {
                    const batch = writeBatch(AppState.db);
                    batch.delete(doc(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/tags`, tagId));
                    AppState.works.filter(w => w.tagIds?.includes(tagId)).forEach(work => {
                        const newTagIds = work.tagIds.filter(id => id !== tagId);
                        batch.update(doc(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/items`, work.id), { tagIds: newTagIds });
                    });
                    await batch.commit();
                    App.showToast(`タグ「${tagToDelete.name}」を削除しました。`);
                 } catch(error) {
                    console.error("Error deleting tag:", error);
                    App.showToast("タグの削除中にエラーが発生しました。", "error");
                 }
            },

            // --- Rendering Logic ---
            saveShowSiteIcon: (value) => {
                AppState.showSiteIcon = value;
                localStorage.setItem('showSiteIcon', value);
            },

            renderAll: () => {
                App.renderWorkList();
                App.renderActiveFilters();
                App.renderLotterySummary();
            },

            getSiteBadgeHTML: (url) => {
                if (!AppState.showSiteIcon || !url) return '';
                if (url.includes('dlsite.com')) {
                    return `<span class="site-badge bg-sky-600 text-white">DL</span>`;
                }
                if (url.includes('dmm.co.jp')) {
                    return `<span class="site-badge bg-red-600 text-white">FZ</span>`;
                }
                return '';
            },

            renderWorkList: () => {
                const { ui, isLoadComplete, isDebugMode, works, listViewMode } = AppState;
                if (!ui.workListEl) return;
                 if (!isLoadComplete && !isDebugMode) return;
                
                const filteredWorks = App.getFilteredAndSortedWorks();
                ui.workCountEl.textContent = `${filteredWorks.length} / ${works.length} 作品`;

                ui.viewGridBtn.classList.toggle('view-btn-active', listViewMode === 'grid');
                ui.viewListBtn.classList.toggle('view-btn-active', listViewMode === 'list');
                ui.workListEl.className = listViewMode === 'grid' 
                    ? 'grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6' 
                    : 'space-y-2';
                
                if (works.length === 0) {
                     ui.workListMessage.innerHTML = `<div class="text-center py-10 text-gray-500"><i class="fas fa-ghost fa-3x"></i><p class="mt-4 text-base">まだ作品が登録されていません。<br>左上の「作品登録」から追加してみましょう！</p></div>`;
                     ui.workListMessage.classList.remove('hidden'); ui.workListEl.classList.add('hidden'); return;
                }
                if (filteredWorks.length === 0) {
                     ui.workListMessage.innerHTML = `<div class="text-center py-10 text-gray-500"><i class="fas fa-search-minus fa-3x"></i><p class="mt-4 text-base">条件に一致する作品がありません。<br>絞り込み条件を見直してください。</p></div>`;
                     ui.workListMessage.classList.remove('hidden'); ui.workListEl.classList.add('hidden'); return;
                }
                
                ui.workListMessage.classList.add('hidden'); ui.workListEl.classList.remove('hidden');
                ui.workListEl.innerHTML = filteredWorks.map(listViewMode === 'grid' ? App.renderWorkCard : App.renderWorkListItem).join('');
            },

            renderWorkCard: (work) => {
                const { expandedTagsWorkIds } = AppState;
                const tagObjects = App.getTagObjects(work.tagIds);
                const isExpanded = expandedTagsWorkIds.has(work.id);
                const displayedTags = isExpanded ? tagObjects : tagObjects.slice(0, 5);
                const hasMoreTags = tagObjects.length > 5;
                const ratingStars = Array(5).fill(0).map((_, i) => `<i class="fa-star ${i < work.rating ? 'fas text-yellow-400' : 'far text-gray-500'}"></i>`).join('');
                const safeWorkName = App.escapeHTML(work.name);
                const siteBadge = App.getSiteBadgeHTML(work.sourceUrl);

                return `... (HTMLは変更なし) ...`; // (省略)
            },

            renderWorkListItem: (work) => {
                const ratingStars = Array(5).fill(0).map((_, i) => `<i class="fa-star ${i < work.rating ? 'fas text-yellow-400' : 'far text-gray-500'}"></i>`).join('');
                const tagObjects = App.getTagObjects(work.tagIds);
                const safeWorkName = App.escapeHTML(work.name);
                const siteBadge = App.getSiteBadgeHTML(work.sourceUrl);

                return `... (HTMLは変更なし) ...`; // (省略)
            },
            
            getContrastColor: (hex) => {
                if (!hex) return '#FFFFFF';
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return (r * 0.299 + g * 0.587 + b * 0.114) > 186 ? '#000000' : '#FFFFFF';
            },

            getFilteredWorks: (filters, sourceWorks = AppState.works) => {
                let tempWorks = [...sourceWorks];

                // Mood / Rating filter
                if (filters.unratedOrUntaggedOnly) {
                    tempWorks = tempWorks.filter(w => (w.rating || 0) === 0 || !w.tagIds || w.tagIds.length === 0);
                } else if (filters.mood) { // Lottery
                    if (filters.mood === 'best') tempWorks = tempWorks.filter(w => (w.rating || 0) >= 4);
                    if (filters.mood === 'hidden_gem') tempWorks = tempWorks.filter(w => (w.rating || 0) <= 2);
                } else if (filters.rating && filters.rating.value > 0) { // List
                    tempWorks = filters.rating.type === 'exact' 
                        ? tempWorks.filter(w => w.rating === filters.rating.value)
                        : tempWorks.filter(w => w.rating >= filters.rating.value);
                }

                // Genre filter
                if (filters.genres && filters.genres.size > 0) {
                    tempWorks = tempWorks.filter(w => filters.genres.has(w.genre));
                }
                
                // Date filter
                if (filters.dateFilter) {
                    const { mode, date, startDate, endDate } = filters.dateFilter;
                    if (mode === 'specific' && date && App.isValidDate(date)) {
                        const start = new Date(date); start.setHours(0,0,0,0);
                        const end = new Date(date); end.setHours(23,59,59,999);
                        tempWorks = tempWorks.filter(w => w.registeredAt && w.registeredAt.toDate() >= start && w.registeredAt.toDate() <= end);
                    } else if (mode === 'range' && startDate && endDate && App.isValidDate(startDate) && App.isValidDate(endDate)) {
                         const start = new Date(startDate); start.setHours(0,0,0,0);
                         const end = new Date(endDate); end.setHours(23,59,59,999);
                         tempWorks = tempWorks.filter(w => w.registeredAt && w.registeredAt.toDate() >= start && w.registeredAt.toDate() <= end);
                    }
                }
                
                // Tag filter
                const andTags = filters.andTagIds || new Set();
                if (andTags && andTags.size > 0) {
                    tempWorks = tempWorks.filter(w => w.tagIds && [...andTags].every(tid => w.tagIds.includes(tid)));
                }
                if (filters.orTagIds && filters.orTagIds.size > 0) {
                    tempWorks = tempWorks.filter(w => w.tagIds && [...filters.orTagIds].some(tid => w.tagIds.includes(tid)));
                }
                if (filters.notTagIds && filters.notTagIds.size > 0) {
                    tempWorks = tempWorks.filter(w => !w.tagIds || ![...filters.notTagIds].some(tid => w.tagIds.includes(tid)));
                }

                return tempWorks;
            },
            
            getFilteredAndSortedWorks: () => {
                let tempWorks = App.getFilteredWorks(AppState.listFilters);
                const { searchQuery, sortState } = AppState;

                if (searchQuery) {
                    tempWorks = tempWorks.filter(w => w.name.toLowerCase().includes(searchQuery.toLowerCase()));
                }

                return tempWorks.sort((a, b) => {
                    const order = sortState.order === 'asc' ? 1 : -1;
                    const aTime = a.registeredAt?.toMillis() || 0;
                    const bTime = b.registeredAt?.toMillis() || 0;
                    const aLastTime = a.lastSelectedAt?.toMillis() || 0;
                    const bLastTime = b.lastSelectedAt?.toMillis() || 0;

                    switch (sortState.by) {
                        case 'name': return a.name.localeCompare(b.name, 'ja') * order;
                        case 'genre': return a.genre.localeCompare(b.genre, 'ja') * order;
                        case 'registeredAt': return (aTime - bTime) * order;
                        case 'lastSelectedAt': return (aLastTime - bLastTime) * order;
                        default: return 0;
                    }
                });
            },

            renderActiveFilters: () => {
                const { listFilters, tags } = AppState;
                const filters = [];
                listFilters.genres.forEach(g => filters.push({type: 'genre', value: g, label: `ジャンル: ${g}`}));
                
                if (listFilters.unratedOrUntaggedOnly) {
                    filters.push({type: 'unrated', label: '未評価/未タグ'});
                } else if (listFilters.rating.value > 0) {
                    filters.push({type: 'rating', label: `評価: ${'★'.repeat(listFilters.rating.value)}${listFilters.rating.type === 'above' ? '以上' : ''}`});
                }

                const addTagFilters = (tagIds, prefix, type) => {
                    tagIds.forEach(tId => {
                        const tag = tags.get(tId);
                        if (tag) filters.push({type: type, value: tId, label: `${prefix}: ${tag.name}`});
                    });
                };
                addTagFilters(listFilters.andTagIds, 'AND', 'andTag');
                addTagFilters(listFilters.orTagIds, 'OR', 'orTag');
                addTagFilters(listFilters.notTagIds, 'NOT', 'notTag');

                const { mode, date, startDate, endDate } = listFilters.dateFilter;
                if (mode === 'specific' && date) filters.push({type: 'date', label: `登録日: ${date}`});
                if (mode === 'range' && startDate && endDate) filters.push({type: 'date', label: `期間: ${startDate} ~ ${endDate}`});

                AppState.ui.activeFiltersEl.innerHTML = (filters.length === 0)
                    ? `<span class="text-sm text-gray-400">絞り込み: なし</span>`
                    : `<span class="text-sm text-gray-400 mr-2">絞り込み:</span>` + filters.map(f => `
                        <span class... (HTMLは変更なし) ...>...</span>`).join('');
            },
            
            renderLotterySummary: () => {
                 const { mood, genres, andTagIds, orTagIds, notTagIds, dateFilter, priority, method, unratedOrUntaggedOnly } = AppState.lotterySettings;
                 const moodMap = { default: '問わない', favorite: 'お気に入り', best: '最高評価', hidden_gem: '隠れた名作' };
                 const priorityMap = { new: '新しい順', old: '古い順', random: 'ランダム' };
                 const methodMap = { normal: '通常', decrease_unselected: '未選択優先' };
                 const summaryParts = [];

                if (unratedOrUntaggedOnly) {
                    summaryParts.push('未評価/未タグ付のみ');
                } else {
                    summaryParts.push(`気分: ${moodMap[mood]}`);
                }
                 if (genres.size > 0) summaryParts.push(`ジャンル: ${[...genres].join(', ')}`);
                 if (andTagIds.size > 0) summaryParts.push(`タグ(AND): ${andTagIds.size}件`);
                 if (orTagIds.size > 0) summaryParts.push(`タグ(OR): ${orTagIds.size}件`);
                 if (notTagIds.size > 0) summaryParts.push(`タグ(NOT): ${notTagIds.size}件`);
                 if (dateFilter.mode === 'specific' && dateFilter.date) summaryParts.push(`登録日: ${dateFilter.date}`);
                 if (dateFilter.mode === 'range' && dateFilter.startDate && dateFilter.endDate) summaryParts.push(`期間: ${dateFilter.startDate} ~ ${dateFilter.endDate}`);
                 summaryParts.push(`優先度: ${priorityMap[priority]}`);
                 summaryParts.push(`方法: ${methodMap[method]}`);

                 AppState.ui.lotterySummaryEl.innerHTML = (
                    mood === 'default' && 
                    genres.size === 0 && 
                    andTagIds.size === 0 && orTagIds.size === 0 && notTagIds.size === 0 &&
                    dateFilter.mode === 'none' &&
                    !unratedOrUntaggedOnly
                 )
                     ? `<p class="text-gray-400">設定を開いて条件を選択してください。</p>`
                     : summaryParts.map(s => `<span class="inline-block bg-gray-600 px-2 py-1 rounded text-xs mr-1 mb-1">${s}</span>`).join('');
            },

            // --- Event Handlers & Site Search ---
            openSearchWindow: (site, query) => {
                let url;
                const encodedQuery = encodeURIComponent(query);
                switch(site) {
                    case 'dlsite': url = query ? `https://www.dlsite.com/maniax/fsr/=/language/jp/sex_category%5B0%5D/male/keyword/${encodedQuery}/` : 'https://www.dlsite.com/maniax/'; break;
                    case 'fanza': url = query ? `https://www.dmm.co.jp/dc/doujin/-/list/narrow/=/word=${encodedQuery}/` : 'https://www.dmm.co.jp/dc/doujin/'; break;
                    case 'melonbooks': url = query ? `https://www.melonbooks.co.jp/search/search.php?name=${encodedQuery}&search_target=2` : 'https://www.melonbooks.co.jp/'; break;
                    case 'booth': url = query ? `https://booth.pm/ja/search/${encodedQuery}` : 'https://booth.pm/'; break;
                }
                if (url) {
                    window.open(url, '_blank', 'noopener,noreferrer');
                }
            },

            setupEventListeners: () => {
                const { ui } = AppState; // UI要素の参照をまとめて取得

                ui.modalCloseBtn.addEventListener('click', App.closeModal);
                ui.modalBackdrop.addEventListener('click', App.closeModal);
                ui.slidingFabToggle.addEventListener('click', App.toggleFabMenu);
                ui.fabBackdrop.addEventListener('click', App.closeFabMenu);

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        // 開いているモーダルのうち、一番手前のものを閉じる
                        if (AppState.ui.imageCompareModal.classList.contains('active')) {
                            App.closeImageCompareModal();
                        } else if (!AppState.ui.modalWrapper.classList.contains('hidden')) {
                            App.closeModal();
                        } else if (!AppState.ui.fabBackdrop.classList.contains('hidden')) {
                            // (おまけ) FABメニューもEscで閉じる
                            App.closeFabMenu();
                        }
                    }
                });

                // (Grok/ChatGPT案: イベント委譲)
                // body へのクリックイベントリスナーをリファクタリング
                document.body.addEventListener('click', e => {
                    const button = e.target.closest('button[data-action]');
                    const nameSpan = e.target.closest('[data-action="copy-name"]');
                    const filterButton = e.target.closest('button[data-action="remove-filter"]');

                    if (button) {
                        const { action, id, name } = button.dataset;
                        switch (action) {
                            case 'edit': App.openEditModal(id); break;
                            case 'delete': App.deleteWork(id, name); break;
                            case 'toggle-tags':
                                AppState.expandedTagsWorkIds.has(id) ? AppState.expandedTagsWorkIds.delete(id) : AppState.expandedTagsWorkIds.add(id);
                                App.renderWorkList();
                                break;
                            case 'external-search-reg': {
                                const query = $('#workNameInput').value.trim();
                                App.openExternalSearchModal(query);
                                break;
                            }
                        }
                    }
                    if (nameSpan) {
                        ui.searchInput.value = nameSpan.dataset.name;
                        ui.searchInput.focus();
                        App.showToast(`「${nameSpan.dataset.name}」を検索欄にコピーしました。`);
                    }
                    if (filterButton) {
                        const { type, value } = filterButton.dataset;
                        switch(type) {
                            case 'genre': AppState.listFilters.genres.delete(value); break;
                            case 'rating': AppState.listFilters.rating = { type: 'exact', value: 0 }; break;
                            case 'unrated': AppState.listFilters.unratedOrUntaggedOnly = false; break;
                            case 'andTag': AppState.listFilters.andTagIds.delete(value); break;
                            case 'orTag': AppState.listFilters.orTagIds.delete(value); break;
                            case 'notTag': AppState.listFilters.notTagIds.delete(value); break;
                            case 'date': AppState.listFilters.dateFilter = AppState.defaultDateFilter(); break;
                        }
                        App.renderAll();
                    }
                });
                
                ui.copySyncIdBtn.addEventListener('click', () => navigator.clipboard.writeText(AppState.syncId).then(() => App.showToast("同期IDをコピーしました。")));
                
                ui.loadSyncIdBtn.addEventListener('click', () => {
                    const newId = ui.newSyncIdInput.value.trim();
                    if (newId && newId !== AppState.syncId) {
                        App.loadDataSet(newId);
                        App.updateSyncIdHistory(newId);
                        ui.newSyncIdInput.value = '';
                        App.showToast("データを読み込みました。");
                    }
                });
                
                ui.syncIdHistoryEl.addEventListener('change', e => e.target.value && App.loadDataSet(e.target.value));
                
                ui.clearHistoryBtn.addEventListener('click', async () => {
                    if (await App.showConfirm('履歴のクリア', '本当に同期IDの履歴をクリアしますか？')) {
                        localStorage.removeItem('r18_sync_id_history');
                        App.renderSyncIdHistory(); App.showToast("履歴をクリアしました。");
                    }
                });
                
                ui.deleteDataBtn.addEventListener('click', async () => {
                     if (AppState.isDebugMode) return App.showToast('デバッグモード中は全削除できません。');
                     if (await App.showConfirm('全作品データ削除', `現在のID (<strong>${AppState.syncId}</strong>) に紐づく全ての作品データを削除します。<br>この操作は元に戻せません。`)) {
                        try {
                            const batch = writeBatch(AppState.db);
                            const worksRef = collection(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/items`);
                            const worksSnapshot = await getDocs(worksRef);
                            worksSnapshot.forEach(doc => batch.delete(doc.ref));
                            
                            const tagsRef = collection(AppState.db, `/artifacts/${AppState.appId}/public/data/r18_works_sync/${AppState.syncId}/tags`);
                            const tagsSnapshot = await getDocs(tagsRef);
                            tagsSnapshot.forEach(doc => batch.delete(doc.ref));

                            await batch.commit();
                            App.showToast("全ての作品・タグデータを削除しました。");
                        } catch(error) { 
                            console.error("Error deleting all data:", error);
                            App.showToast("データ削除中にエラーが発生しました。"); 
                        }
                     }
                });
                
                ui.addWorkForm.addEventListener('submit', App.handleAddWork);
                
                $('#workRegisteredAt').value = App.formatDateForInput(new Date()); // これは動的要素なので$のまま
                $('#toggleDebugModeBtn').addEventListener('click', App.toggleDebugMode); // 同上

                $('#workImage').addEventListener('change', e => {
                    const file = e.target.files[0];
                    const preview = $('#imagePreview');
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = event => { preview.src = event.target.result; preview.classList.remove('hidden'); };
                        reader.readAsDataURL(file);
                    } else { preview.classList.add('hidden'); }
                });
                
                ui.searchInput.addEventListener('input', App.debounce(() => { AppState.searchQuery = ui.searchInput.value; App.renderWorkList(); }, 300));
                
                ui.sortBtn.addEventListener('click', (e) => { e.stopPropagation(); ui.sortDropdown.classList.toggle('hidden'); });
                document.addEventListener('click', () => ui.sortDropdown.classList.add('hidden'));
                
                const setupSortOptions = () => {
                    const options = [
                        { by: 'registeredAt', order: 'desc', label: '登録日 (新しい順)' }, { by: 'registeredAt', order: 'asc', label: '登録日 (古い順)' },
                        { by: 'name', order: 'asc', label: '作品名 (昇順)' }, { by: 'name', order: 'desc', label: '作品名 (降順)' },
                        { by: 'lastSelectedAt', order: 'desc', label: '抽選日 (新しい順)' }, { by: 'lastSelectedAt', order: 'asc', label: '抽選日 (古い順)' },
                        { by: 'genre', order: 'asc', label: 'ジャンル (昇順)' },
                    ];
                    ui.sortDropdown.innerHTML = options.map(opt => `<a href="#" data-by="${opt.by}" data-order="${opt.order}" class="block px-4 py-2 text-sm text-gray-200 hover:bg-gray-600">${opt.label}</a>`).join('');
                    ui.sortDropdown.addEventListener('click', (e) => {
                         e.preventDefault();
                         const target = e.target.closest('a');
                         if (target) {
                            AppState.sortState.by = target.dataset.by; AppState.sortState.order = target.dataset.order;
                            ui.sortStateLabel.textContent = `並び替え: ${target.textContent}`;
                            ui.sortDropdown.classList.add('hidden'); App.renderWorkList();
                         }
                    });
                };
                setupSortOptions();
                
                ui.filterBtn.addEventListener('click', () => App.openFilterModal());
                ui.viewGridBtn.addEventListener('click', () => { AppState.listViewMode = 'grid'; localStorage.setItem('listViewMode', 'grid'); App.renderWorkList(); });
                ui.viewListBtn.addEventListener('click', () => { AppState.listViewMode = 'list'; localStorage.setItem('listViewMode', 'list'); App.renderWorkList(); });
                
                // (Grok/ChatGPT案: FABメニュー選択後に自動で閉じる)
                ui.manageTagsFab.addEventListener('click', () => { App.openTagModal({ mode: 'manage', onConfirm: ()=>{} }); App.closeFabMenu(); });
                ui.statsFab.addEventListener('click', () => { App.openStatsDashboardModal(); App.closeFabMenu(); });
                ui.externalSearchFab.addEventListener('click', () => { App.openExternalSearchModal(ui.searchInput.value); App.closeFabMenu(); });
                ui.historyFab.addEventListener('click', () => { App.openHistoryModal(); App.closeFabMenu(); });
                
                ui.openLotterySettingsBtn.addEventListener('click', () => App.openLotterySettingsModal());
                ui.startLotteryBtn.addEventListener('click', App.performLottery);

                const lotteryPanel = $('#lottery-panel');
                if (lotteryPanel && ui.drawerLotteryFab) {
                    ui.drawerLotteryFab.addEventListener('click', () => {
                        lotteryPanel.scrollIntoView({ behavior: 'smooth' });
                        App.closeFabMenu();
                    });
                }
                
                // 画像比較モーダル関連
                ui.imageCompareCloseBtn.addEventListener('click', () => App.closeImageCompareModal());
                ui.imageCompareModalBackdrop.addEventListener('click', () => App.closeImageCompareModal());
                ui.imageCompareCancelBtn.addEventListener('click', () => {
                    App.closeImageCompareModal();
                    App.showToast("画像の変更をキャンセルしました。", "info");
                });
                ui.imageCompareConfirmBtn.addEventListener('click', () => {
                    App.closeImageCompareModal(false);
                    
                    const editCurrentImagePreview = $('#edit-current-image-preview');
                    const editNoImagePlaceholder = $('#edit-no-image-placeholder');
                    const editImageDeleteBtn = $('#edit-image-delete-btn');
                    
                    if (editCurrentImagePreview && AppState.tempNewImageUrl) {
                        editCurrentImagePreview.src = AppState.tempNewImageUrl;
                        editCurrentImagePreview.classList.remove('hidden');
                        editNoImagePlaceholder.classList.add('hidden');
                        editImageDeleteBtn.classList.remove('hidden');
                        AppState.deleteImageFlag = false;
                    }
                    
                    App.showToast("新しい画像が適用されます。保存ボタンで確定してください。", "success");
                });
            },

            // --- Modal Implementations ---
            
            openExternalSearchModal: (prefillQuery = '') => {
                // ... (中身のロジックは App. や AppState. を使うように変更) ...
                // 例: openSearchWindow(...) -> App.openSearchWindow(...)
                const sites = [ ... ];
                const safeQuery = App.escapeHTML(prefillQuery);
                const content = `...`;
                
                App.openModal("外部サイトで検索", content, () => {
                    $('#external-site-buttons').addEventListener('click', e => {
                        const button = e.target.closest('button[data-site]');
                        if (button) {
                            const site = button.dataset.site;
                            const query = $('#externalSearchInput').value.trim();
                            App.openSearchWindow(site, query); // 修正
                        }
                    });
                });
            },
            
            openHistoryModal: () => {
                const allHistory = [];
                AppState.works.forEach(work => { // 修正
                    if (work.selectionHistory && work.selectionHistory.length > 0) {
                        work.selectionHistory.forEach(timestamp => {
                            allHistory.push({
                                workId: work.id,
                                workName: work.name,
                                timestamp: timestamp
                            });
                        });
                    }
                });
                // ... (中身のロジックは App. や AppState. を使うように変更) ...
                // 例: formatDate(...) -> App.formatDate(...)
                // 例: closeModal() -> App.closeModal()
                // 例: openEditModal(...) -> App.openEditModal(...)

                allHistory.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());
            
                let content;
                if (allHistory.length > 0) {
                    content = `
                        <div class="max-h-[60vh] overflow-y-auto pr-2">
                            <ul id="history-list-ul" class="space-y-2"> ${allHistory.map(entry => `
                                    <li>
                                        <button data-id="${entry.workId}" class="w-full text-left bg-gray-700 p-3 rounded-lg flex justify-between items-center text-sm transition-colors hover:bg-gray-600">
                                            <span class="font-semibold">${entry.workName}</span>
                                            <span class="text-gray-400">${App.formatDate(entry.timestamp)}</span>
                                        </button>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>`;
                } else {
                    content = `<div class="text-center py-10 text-gray-500"><i class="fas fa-history fa-3x"></i><p class="mt-4">まだ抽選履歴はありません。</p></div>`;
                }

                App.openModal("総合抽選履歴", content, () => {
                    const listEl = $('#history-list-ul');
                    if (!listEl) return; // コンテナがない場合は何もしない
                    listEl.addEventListener('click', e => {
                        const button = e.target.closest('button[data-id]');
                        if (button) {
                            const workId = button.dataset.id;
                            if (workId) {
                                App.closeModal(); 
                                setTimeout(() => {
                                    App.openEditModal(workId);
                                }, 300); 
                            }
                        }
                    });
                }, { size: 'max-w-3xl' });
            },

            openEditModal: (workId, tempState = null) => {
                const work = AppState.works.find(w => w.id === workId);
                if (!work) return;
                let currentRating = tempState?.rating ?? (work.rating || 0);
                let currentTagIds = tempState?.tagIds ?? new Set(work.tagIds || []);
                const safeWorkName = App.escapeHTML(work.name);
                const safeWorkUrl = App.escapeHTML(work.sourceUrl || '');

                const pool = App.getLotteryPool(); // 修正
                const thisWorkInPool = pool.find(w => w.id === workId);
                const totalWeight = pool.reduce((sum, w) => sum + w.weight, 0);
                let probabilityText;
                if (thisWorkInPool) {
                    const probability = totalWeight > 0 ? (thisWorkInPool.weight / totalWeight * 100).toFixed(2) : '0.00';
                    probabilityText = `<span class="font-bold text-sky-400 text-base">${probability}%</span>`;
                } else {
                     probabilityText = `<span class="font-bold text-gray-500">対象外</span>`;
                }

                const content = `... (HTMLは変更なし、ただし createDateInputHTML を App.createDateInputHTML に) ...`;
                // createDateInputHTML(...) を App.createDateInputHTML(...) に変更
                content = content.replace(
                    '${createDateInputHTML(\'editWorkRegisteredAt\',', 
                    '${App.createDateInputHTML(\'editWorkRegisteredAt\','
                );


                App.openModal(`「${work.name}」を編集`, content, () => {
                    const ratingStars = $('#editWorkRating'), tagsContainer = $('#editWorkTags');
                    const workNameInput = $('#editWorkName');
                    const workUrlInput = $('#editWorkUrl');
                    
                    const editImageUpload = $('#edit-image-upload');
                    const editCurrentImagePreview = $('#edit-current-image-preview');
                    const editImageDeleteBtn = $('#edit-image-delete-btn');
                    const editNoImagePlaceholder = $('#edit-no-image-placeholder');
                    
                    AppState.tempNewImageUrl = null;
                    AppState.deleteImageFlag = false;

                    editImageDeleteBtn.addEventListener('click', () => {
                        if (confirm('本当に画像を削除しますか？')) {
                            editCurrentImagePreview.src = '';
                            editCurrentImagePreview.classList.add('hidden');
                            editImageDeleteBtn.classList.add('hidden');
                            editNoImagePlaceholder.classList.remove('hidden');
                            AppState.deleteImageFlag = true;
                            AppState.tempNewImageUrl = null;
                            editImageUpload.value = '';
                            App.showToast("画像を削除候補にしました。保存で確定されます。", "info");
                        }
                    });

                    editImageUpload.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (!file) {
                            AppState.tempNewImageUrl = null;
                            return;
                        }
                        try {
                            const newUrl = await App.processImage(file);
                            App.openImageCompareModal(work.imageUrl || '', newUrl);
                            AppState.tempNewImageUrl = newUrl; // 一時保存
                        } catch (error) {
                            App.showToast(error.message || "画像処理に失敗しました。", "error");
                            editImageUpload.value = '';
                            AppState.tempNewImageUrl = null;
                        }
                    });

                    const openUrlBtn = $('#openWorkUrlBtn');
                    workUrlInput.addEventListener('input', () => {
                        openUrlBtn.disabled = !workUrlInput.value.trim();
                    });
                    openUrlBtn.addEventListener('click', () => {
                        const url = workUrlInput.value.trim();
                        if (url) window.open(url, '_blank', 'noopener,noreferrer');
                    });
                    
                    $('#copy-edit-title-btn').addEventListener('click', () => {
                        navigator.clipboard.writeText(workNameInput.value).then(() => {
                            App.showToast(`「${workNameInput.value}」をコピーしました。`);
                        });
                    });

                    const getFormState = () => { ... }; // (変更なし)
                    const initialState = getFormState();
                    AppState.checkModalDirtyState = () => { ... }; // (変更なし)
                    
                    $('#edit-external-search').addEventListener('click', () => {
                         const capturedState = { rating: currentRating, tagIds: currentTagIds };
                        AppState.modalStateStack.push(() => App.openEditModal(workId, capturedState)); // 修正
                        App.openExternalSearchModal(workNameInput.value); // 修正
                    });

                    const renderStars = r => { ratingStars.innerHTML = [1,2,3,4,5].map(i => `<i class="fa-star cursor-pointer ${i <= r ? 'fas text-yellow-400' : 'far text-gray-500'}" data-value="${i}"></i>`).join(''); };
                    const renderTags = ids => {
                        const objects = App.getTagObjects(ids); // 修正
                        tagsContainer.innerHTML = objects.length > 0 ? objects.map(t => `<span ...>${t.name}</span>`).join('') : `<span ...>タグなし</span>`;
                    };
                    renderStars(currentRating);
                    renderTags(currentTagIds);

                    ratingStars.addEventListener('click', e => { ... }); // (変更なし)
                    
                    $('#editWorkAssignTagsBtn').addEventListener('click', () => {
                        App.openTagModal({ // 修正
                            mode: 'assign', workId, currentTagIds, workName: work.name,
                            onConfirm: (newTagIds) => {
                                 if(newTagIds) currentTagIds = newTagIds;
                                 App.openEditModal(workId, { rating: currentRating, tagIds: currentTagIds }) // 修正
                            }
                        });
                    });
                    
                    $('#edit-cancel-btn').addEventListener('click', App.closeModal); // 修正
                    
                    $('#editWorkForm').addEventListener('submit', async e => {
                        e.preventDefault();
                        if (!workNameInput || !workNameInput.value.trim()){
                            return App.showToast("作品名は必須です。", "error"); // 修正
                        }
                        const registeredAtStr = App.getDateInputValue('editWorkRegisteredAt'); // 修正
                        if (!App.isValidDate(registeredAtStr)) return App.showToast("登録日の形式が不正です (YYYY/MM/DD)。", "error"); // 修正
                        
                        const updatedData = { ... }; // (変更なし)
                        
                        if (AppState.tempNewImageUrl) { // 修正
                            updatedData.imageUrl = AppState.tempNewImageUrl; // 修正
                        } else if (AppState.deleteImageFlag) { // 修正
                            updatedData.imageUrl = deleteField();
                        }

                        AppState.checkModalDirtyState = () => false;
                        if (await App.updateWork(workId, updatedData)) { // 修正
                            App.showToast("作品情報を更新しました。");  // 修正
                            App.closeModal(); // 修正
                        }
                    });
                });
            },
            
            openFilterModal: (tempState = null) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
                // この関数は非常に長いため、すべての置換をここで示すのは省略しますが、
                // openEditModal と同様のロジックで App. をつけてください。
                // 例: createDateFilterHTML(...) -> App.createDateFilterHTML(...)
                // 例: listFilters -> AppState.listFilters
                // 例: tags -> AppState.tags
            },
            
            openTagModal: (options) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            openTagFilterModal: (options) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            // --- Date Filter UI & Logic ---
            createDateFilterHTML: (context, state) => {
                // ... (内部の createDateInputHTML を App.createDateInputHTML に変更) ...
                const html = `...`;
                return html.replace(/createDateInputHTML/g, 'App.createDateInputHTML');
            },
            
            setupDateFilterEventListeners: (context, updateCallback) => {
                 $$(`input[name="date-filter-mode-${context}"]`).forEach(radio => {
                    radio.addEventListener('change', () => {
                        const mode = radio.value;
                        $('#date-filter-specific-' + context).classList.toggle('hidden', mode !== 'specific');
                        $('#date-filter-range-' + context).classList.toggle('hidden', mode !== 'range');
                        updateCallback();
                    });
                });
                const addListener = (id) => {
                    const input = $(`#${id}`);
                    if (!input) return;
                    input.addEventListener('change', updateCallback);
                    input.addEventListener('input', App.debounce(updateCallback, 300)); // 修正
                };
                addListener(`date-filter-specific-date-${context}`);
                addListener(`date-filter-start-date-${context}`);
                addListener(`date-filter-end-date-${context}`);
            },
            
            createDateInputHTML: (id, value) => {
                return `<input type="text" id="${id}" value="${value}" placeholder="YYYY/MM/DD" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-sky-500">`;
            },
            
            initializeDateInputs: (container) => {
                container.querySelectorAll('input[placeholder="YYYY/MM/DD"]').forEach(textInput => {
                    if (textInput.dataset.initialized) return;
                    textInput.dataset.initialized = 'true';
                    const validateDateInput = () => {
                        if (App.isValidDate(textInput.value) || textInput.value === '') { // 修正
                            textInput.classList.remove('border-red-500');
                        } else {
                            textInput.classList.add('border-red-500');
                        }
                    };
                    textInput.addEventListener('input', validateDateInput);
                    textInput.addEventListener('change', validateDateInput);
                });
            },
            
            getDateInputValue: (id) => {
                const input = $(`#${id}`);
                return input ? input.value : '';
            },

            // --- Lottery Logic ---
            getLotteryPool: () => {
                const poolFilters = { ...AppState.lotterySettings }; // 修正
                let pool = App.getFilteredWorks(poolFilters); // 修正
                
                const { priority, method, mood, unratedOrUntaggedOnly } = AppState.lotterySettings; // 修正
                // ... (残りのロジックは変更なし) ...
                return pool.map(work => { ... });
            },

            openLotterySettingsModal: (tempState = null) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            openHelpModal: () => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },

            performLottery: async () => {
                const weightedPool = App.getLotteryPool(); // 修正
                if (weightedPool.length === 0) return App.showToast("抽選対象の作品がありません。"); // 修正
                
                const totalWeight = weightedPool.reduce((sum, work) => sum + work.weight, 0);
                if (totalWeight <= 0) return App.showToast("抽選対象の作品がありません (重み合計が0以下)。"); // 修正

                let random = Math.random() * totalWeight;
                let selectedWork = weightedPool.find(work => (random -= work.weight) <= 0) || weightedPool[weightedPool.length - 1];
                
                localStorage.setItem('lastSelectedWorkId', selectedWork.id);
                if (!AppState.isDebugMode) { // 修正
                    const newHistoryEntry = Timestamp.now();
                    await App.updateWork(selectedWork.id, {  // 修正
                        selectionCount: (selectedWork.selectionCount || 0) + 1, 
                        lastSelectedAt: newHistoryEntry,
                        selectionHistory: arrayUnion(newHistoryEntry)
                    });
                } else {
                     const workIndex = AppState.works.findIndex(w => w.id === selectedWork.id); // 修正
                     if (workIndex !== -1) {
                        AppState.works[workIndex].selectionCount = (AppState.works[workIndex].selectionCount || 0) + 1; // 修正
                        // ...
                     }
                }
                App.openLotteryResultModal(selectedWork); // 修正
            },
            
            openLotteryResultModal: (work, tempState = null) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },

            openFeedbackModal: (work, tempState = null) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },

            // --- Stats Dashboard Logic ---
            openStatsDashboardModal: () => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            setupChartDefaults: () => {
                // ... (変更なし) ...
            },

            renderStatsOverview: () => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            renderTrendsChart: (mode) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            renderTrendsDetail: (key, data) => {
                // ... (すべての内部ロジックを App. や AppState. を使うように変更) ...
            },
            
            // --- Debug Mode ---
            generateDebugData: () => {
                // ... (変更なし、ただし Timestamp を AppState.Timestamp にする必要があるが、
                // この関数内ではTimestampはグローバルスコープのimportから直接参照されているためOK) ...
                return { works: newWorks, tags: newTags };
            },
            
            toggleDebugMode: async () => {
                const btn = $('#toggleDebugModeBtn');
                const syncPanel = $('#sync-panel-details');
                const regPanel = $('#registration-panel-details');
                
                if (AppState.isDebugMode) { // 修正
                    // --- Exit Debug Mode ---
                    if (!await App.showConfirm("デバッグモード終了", "デバッグモードを終了し、データベースからデータを再読み込みしますか？")) return; // 修正
                    
                    AppState.isDebugMode = false; // 修正
                    $('#debug-banner').classList.add('hidden');
                    // ... (ボタンのスタイル変更) ...
                    
                    AppState.works = []; // 修正
                    AppState.tags = []; // 修正
                    App.showToast("デバッグモードを終了しました。"); // 修正
                    App.loadDataSet(AppState.syncId); // 修正
                } else {
                    // --- Enter Debug Mode ---
                    if (!await App.showConfirm("デバッグモード開始", "デバッグモードを開始しますか？<br>...")) return; // 修正

                    AppState.isDebugMode = true; // 修正
                    AppState.unsubscribeWorks(); // 修正
                    AppState.unsubscribeTags(); // 修正
                    
                    const debugData = App.generateDebugData(); // 修正
                    AppState.works = debugData.works; // 修正
                    AppState.tags = debugData.tags; // 修正
                    
                    // ... (UIのスタイル変更) ...
                    
                    App.showToast("デバッグモードを開始しました。"); // 修正
                    App.renderAll(); // 修正
                }
            }
        }; // --- End of App Object ---
        

        // --- 4. App Initialization ---
        // (Grok/ChatGPT案: 構造化)
        // 起動処理を App.init() の呼び出しに変更
        document.addEventListener('DOMContentLoaded', App.init);

    </script>
</body>
</html>
